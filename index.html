<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const content = document.querySelector('.content');
    const contentRect = content.getBoundingClientRect();
    const boundaryTop = contentRect.top - 50;
    const boundaryBottom = contentRect.bottom + 50;
    const boundaryLeft = contentRect.left - 50;
    const boundaryRight = contentRect.right + 50;

    let mouseX = 0;
    let mouseY = 0;
    const pushRadius = 100; // Distance within which nodes are pushed away from the cursor

    const nodes = [];
    const edges = [];
    const numNodes = 15;
    const nodeRadius = 5;
    const edgeLength = 100;
    const spaceMargin = 30;

    // Initialize nodes
    for (let i = 0; i < numNodes; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (Math.min(canvas.width, canvas.height) / 2 - edgeLength);
        const node = {
            x: Math.cos(angle) * radius + canvas.width / 2,
            y: Math.sin(angle) * radius + canvas.height / 2,
            vx: Math.random() - 0.5,
            vy: Math.random() - 0.5
        };
        nodes.push(node);
    }

    // Initialize edges
    for (let i = 0; i < numNodes; i++) {
        const targetIndex = Math.floor(Math.random() * numNodes);
        if (i !== targetIndex) {
            edges.push({ source: i, target: targetIndex });
        }
    }

    // Mouse move event listener
    canvas.addEventListener('mousemove', function(event) {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
    });

    function drawGraph() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Push nodes away from the cursor
        nodes.forEach(node => {
            let dx = mouseX - node.x;
            let dy = mouseY - node.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < pushRadius) {
                dx /= distance;
                dy /= distance;
                node.vx -= dx * 0.5;
                node.vy -= dy * 0.5;
            }
        });

        // Draw edges
        ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
        ctx.lineWidth = 1;
        edges.forEach(edge => {
            const sourceNode = nodes[edge.source];
            const targetNode = nodes[edge.target];
            ctx.beginPath();
            ctx.moveTo(sourceNode.x, sourceNode.y);
            ctx.lineTo(targetNode.x, targetNode.y);
            ctx.stroke();
        });

        // Draw nodes
        ctx.fillStyle = 'rgba(0, 123, 255, 0.7)';
        nodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
            ctx.fill();

            // Update node position
            node.x += node.vx;
            node.y += node.vy;

            // Bounce off the text area
            if (node.x < boundaryLeft + nodeRadius + spaceMargin || node.x > boundaryRight - nodeRadius - spaceMargin) {
                node.vx *= -1;
                node.vy *= -1;
            }
            if (node.y < boundaryTop + nodeRadius + spaceMargin || node.y > boundaryBottom - nodeRadius - spaceMargin) {
                node.vx *= -1;
                node.vy *= -1;
            }
        });

        requestAnimationFrame(drawGraph);
    }

    drawGraph();
</script>
