<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Graph Arena Dataset</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            overflow: hidden;
            background-color: #f8f9fa;
        }
        h1 {
            text-align: center;
            color: #007bff;
            margin-top: 50px;
        }
        .download-button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #007bff;
            color: #fff;
            text-decoration: none;
            border-radius: 4px;
            margin-top: 30px;
            font-size: 18px;
            transition: background-color 0.3s ease;
        }
        .download-button:hover {
            background-color: #0056b3;
        }
        canvas {
            position: absolute;
            top: 0;
            z-index: -1;
        }
        #graphCanvas1 {
            left: 0;
        }
        #graphCanvas2 {
            right: 0;
        }
        .content {
            position: relative;
            z-index: 1;
            margin: 100px auto;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <canvas id="graphCanvas1"></canvas>
    <canvas id="graphCanvas2"></canvas>

    <div class="content">
        <h1>Visual Graph Arena Dataset</h1>
        <p>Welcome to the Visual Graph Arena dataset page! This dataset is designed for deep learning research in the field of graph theory.</p>
        <p>The dataset contains a collection of graph data and associated visual representations suitable for various graph-related tasks such as graph classification, graph generation, and graph embedding.</p>

        <h2>Dataset Details</h2>
        <ul>
            <li>Number of graphs: [Insert number of graphs]</li>
            <li>Graph types: [Insert graph types, e.g., directed, undirected, weighted]</li>
            <li>Application domains: [Insert application domains, e.g., social networks, biological networks]</li>
            <li>File format: [Insert file format, e.g., GraphML, JSON]</li>
        </ul>

        <h2>Download</h2>
        <p>To download the Visual Graph Arena dataset, click the button below:</p>
        <a href="[Insert download link]" class="download-button">Download Dataset</a>

        <h2>Citation</h2>
        <p>If you use this dataset in your research, please cite the following paper:</p>
        <pre>
[Insert citation information]
        </pre>

        <h2>Contact</h2>
        <p>If you have any questions or feedback regarding the Visual Graph Arena dataset, please contact us at [Insert contact email].</p>
    </div>

    <script>
        const canvas1 = document.getElementById('graphCanvas1');
        const ctx1 = canvas1.getContext('2d');
        canvas1.width = window.innerWidth / 2;
        canvas1.height = window.innerHeight;

        const canvas2 = document.getElementById('graphCanvas2');
        const ctx2 = canvas2.getContext('2d');
        canvas2.width = window.innerWidth / 2;
        canvas2.height = window.innerHeight;

        const content = document.querySelector('.content');
        const contentRect = content.getBoundingClientRect();
        const boundaryTop = contentRect.top - 50;
        const boundaryBottom = contentRect.bottom + 50;
        const boundaryLeft1 = contentRect.left - 50;
        const boundaryRight1 = contentRect.left;
        const boundaryLeft2 = contentRect.right;
        const boundaryRight2 = contentRect.right + 50;

        const nodes1 = [];
        const edges1 = [];
        const nodes2 = [];
        const edges2 = [];
        const numNodes = 15;
        const nodeRadius = 5;
        const edgeLength = 80;

        // Initialize nodes for graph 1
        for (let i = 0; i < numNodes; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (Math.min(canvas1.width, canvas1.height) / 2 - edgeLength);
            const node = {
                x: Math.cos(angle) * radius + canvas1.width / 2,
                y: Math.sin(angle) * radius + canvas1.height / 2,
                vx: Math.random() - 0.5,
                vy: Math.random() - 0.5
            };
            nodes1.push(node);
        }

        // Initialize edges for graph 1
        for (let i = 0; i < numNodes; i++) {
            const targetIndex = Math.floor(Math.random() * numNodes);
            if (i !== targetIndex) {
                edges1.push({ source: i, target: targetIndex });
            }
        }

        // Initialize nodes for graph 2
        for (let i = 0; i < numNodes; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (Math.min(canvas2.width, canvas2.height) / 2 - edgeLength);
            const node = {
                x: Math.cos(angle) * radius + canvas2.width / 2,
                y: Math.sin(angle) * radius + canvas2.height / 2,
                vx: Math.random() - 0.5,
                vy: Math.random() - 0.5
            };
            nodes2.push(node);
        }

        // Initialize edges for graph 2
        for (let i = 0; i < numNodes; i++) {
            const targetIndex = Math.floor(Math.random() * numNodes);
            if (i !== targetIndex) {
                edges2.push({ source: i, target: targetIndex });
            }
        }

        function drawGraph1() {
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);

            // Draw edges for graph 1
            ctx1.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx1.lineWidth = 1;
            edges1.forEach(edge => {
                const sourceNode = nodes1[edge.source];
                const targetNode = nodes1[edge.target];
                ctx1.beginPath();
                ctx1.moveTo(sourceNode.x, sourceNode.y);
                ctx1.lineTo(targetNode.x, targetNode.y);
                ctx1.stroke();
            });

            // Draw nodes for graph 1
            ctx1.fillStyle = 'rgba(0, 123, 255, 0.7)';
            nodes1.forEach(node => {
                ctx1.beginPath();
                ctx1.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                ctx1.fill();

                // Update node position for graph 1
                node.x += node.vx;
                node.y += node.vy;

                // Bounce off the edges for graph 1
                if (node.x < nodeRadius || node.x > canvas1.width - nodeRadius) {
                    node.vx *= -1;
                }
                if (node.y < nodeRadius || node.y > canvas1.height - nodeRadius) {
                    node.vy *= -1;
                }

                // Bounce off the text area for graph 1
                if (node.x > boundaryLeft1 - nodeRadius && node.x < boundaryRight1 + nodeRadius &&
                    node.y > boundaryTop - nodeRadius && node.y < boundaryBottom + nodeRadius) {
                    if (node.x < boundaryLeft1 + nodeRadius || node.x > boundaryRight1 - nodeRadius) {
                        node.vx *= -1;
                    }
                    if (node.y < boundaryTop + nodeRadius || node.y > boundaryBottom - nodeRadius) {
                        node.vy *= -1;
                    }
                }
            });
        }

        function drawGraph2() {
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);

            // Draw edges for graph 2
            ctx2.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx2.lineWidth = 1;
            edges2.forEach(edge => {
                const sourceNode = nodes2[edge.source];
                const targetNode = nodes2[edge.target];
                ctx2.beginPath();
                ctx2.moveTo(sourceNode.x, sourceNode.y);
                ctx2.lineTo(targetNode.x, targetNode.y);
                ctx2.stroke();
            });

            // Draw nodes for graph 2
            ctx2.fillStyle = 'rgba(0, 123, 255, 0.7)';
            nodes2.forEach(node => {
                ctx2.beginPath();
                ctx2.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                ctx2.fill();

                // Update node position for graph 2
                node.x += node.vx;
                node.y += node.vy;

                // Bounce off the edges for graph 2
                if (node.x < nodeRadius || node.x > canvas2.width - nodeRadius) {
                    node.vx *= -1;
                }
                if (node.y < nodeRadius || node.y > canvas2.height - nodeRadius) {
                    node.vy *= -1;
                }

                // Bounce off the text area for graph 2
                if (node.x > boundaryLeft2 - nodeRadius && node.x < boundaryRight2 + nodeRadius &&
                    node.y > boundaryTop - nodeRadius && node.y < boundaryBottom + nodeRadius) {
                    if (node.x < boundaryLeft2 + nodeRadius || node.x > boundaryRight2 - nodeRadius) {
                        node.vx *= -1;
                    }
                    if (node.y < boundaryTop + nodeRadius || node.y > boundaryBottom - nodeRadius) {
                        node.vy *= -1;
                    }
                }
            });
        }

        function animate() {
            drawGraph1();
            drawGraph2();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
