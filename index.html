<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... (head content remains the same) ... -->
</head>
<body>
    <canvas id="graphCanvas"></canvas>

    <div class="content">
        <!-- ... (content remains the same) ... -->
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const content = document.querySelector('.content');
        const contentRect = content.getBoundingClientRect();
        const boundaryTop = contentRect.top - 50;
        const boundaryBottom = contentRect.bottom + 50;
        const boundaryLeft = contentRect.left - 50;
        const boundaryRight = contentRect.right + 50;

        const nodes = [];
        const edges = [];
        const numNodes = 15;
        const nodeRadius = 5;
        const edgeLength = 100;
        const spaceMargin = 30;

        let mouseX = 0;
        let mouseY = 0;

        // Initialize nodes
        for (let i = 0; i < numNodes; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (Math.min(canvas.width, canvas.height) / 2 - edgeLength);
            const node = {
                x: Math.cos(angle) * radius + canvas.width / 2,
                y: Math.sin(angle) * radius + canvas.height / 2,
                vx: Math.random() - 0.5,
                vy: Math.random() - 0.5
            };
            nodes.push(node);
        }

        // Initialize edges
        for (let i = 0; i < numNodes; i++) {
            const targetIndex = Math.floor(Math.random() * numNodes);
            if (i !== targetIndex) {
                edges.push({ source: i, target: targetIndex });
            }
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx.lineWidth = 1;
            edges.forEach(edge => {
                const sourceNode = nodes[edge.source];
                const targetNode = nodes[edge.target];
                ctx.beginPath();
                ctx.moveTo(sourceNode.x, sourceNode.y);
                ctx.lineTo(targetNode.x, targetNode.y);
                ctx.stroke();
            });

            // Draw nodes
            ctx.fillStyle = 'rgba(0, 123, 255, 0.7)';
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Calculate distance between node and cursor
                const dx = node.x - mouseX;
                const dy = node.y - mouseY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Push the node away from the cursor if it's within a certain range
                const pushRange = 50;
                if (distance < pushRange) {
                    const angle = Math.atan2(dy, dx);
                    const force = (pushRange - distance) / pushRange;
                    node.vx += Math.cos(angle) * force;
                    node.vy += Math.sin(angle) * force;
                }

                // Update node position
                node.x += node.vx;
                node.y += node.vy;

                // Bounce off the text area
                if (node.x < boundaryLeft + nodeRadius + spaceMargin || node.x > boundaryRight - nodeRadius - spaceMargin) {
                    node.vx *= -1;
                }
                if (node.y < boundaryTop + nodeRadius + spaceMargin || node.y > boundaryBottom - nodeRadius - spaceMargin) {
                    node.vy *= -1;
                }
            });

            requestAnimationFrame(drawGraph);
        }

        // Update mouse position
        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        drawGraph();
    </script>
</body>
</html>
