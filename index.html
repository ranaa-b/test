const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const content = document.querySelector('.content');
const contentRect = content.getBoundingClientRect();
const boundaryTop = contentRect.top - 50;
const boundaryBottom = contentRect.bottom + 50;
const boundaryLeft = contentRect.left - 50;
const boundaryRight = contentRect.right + 50;

const nodes = [];
const edges = [];
const numNodes = 15;
const nodeRadius = 5;
const edgeLength = 100;
const spaceMargin = 30;
const repulsionForce = 0.5;
const repulsionDistance = 50;

// Initialize nodes
for (let i = 0; i < numNodes; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * (Math.min(canvas.width, canvas.height) / 2 - edgeLength);
    const node = {
        x: Math.cos(angle) * radius + canvas.width / 2,
        y: Math.sin(angle) * radius + canvas.height / 2,
        vx: Math.random() - 0.5,
        vy: Math.random() - 0.5
    };
    nodes.push(node);
}

// Initialize edges
for (let i = 0; i < numNodes; i++) {
    const targetIndex = Math.floor(Math.random() * numNodes);
    if (i !== targetIndex) {
        edges.push({ source: i, target: targetIndex });
    }
}

function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges
    ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
    ctx.lineWidth = 1;
    edges.forEach(edge => {
        const sourceNode = nodes[edge.source];
        const targetNode = nodes[edge.target];
        ctx.beginPath();
        ctx.moveTo(sourceNode.x, sourceNode.y);
        ctx.lineTo(targetNode.x, targetNode.y);
        ctx.stroke();
    });

    // Draw nodes
    ctx.fillStyle = 'rgba(0, 123, 255, 0.7)';
    nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
        ctx.fill();

        // Repel nodes from the cursor
        const dx = node.x - mouseX;
        const dy = node.y - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < repulsionDistance) {
            const angle = Math.atan2(dy, dx);
            const repulsionX = Math.cos(angle) * repulsionForce;
            const repulsionY = Math.sin(angle) * repulsionForce;
            node.x += repulsionX;
            node.y += repulsionY;
        }

        // Keep nodes within the boundaries
        node.x = Math.max(boundaryLeft + nodeRadius + spaceMargin, Math.min(boundaryRight - nodeRadius - spaceMargin, node.x));
        node.y = Math.max(boundaryTop + nodeRadius + spaceMargin, Math.min(boundaryBottom - nodeRadius - spaceMargin, node.y));
    });

    requestAnimationFrame(drawGraph);
}

let mouseX = 0;
let mouseY = 0;

canvas.addEventListener('mousemove', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

drawGraph();
