<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Graph Arena Dataset</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            overflow: hidden;
            background-color: #f8f9fa;
        }
        h1 {
            text-align: center;
            color: #007bff;
            margin-top: 50px;
        }
        .download-button {
            display: inline-block;
            padding: 12px 24px;
            background-color: #007bff;
            color: #fff;
            text-decoration: none;
            border-radius: 4px;
            margin-top: 30px;
            font-size: 18px;
            transition: background-color 0.3s ease;
        }
        .download-button:hover {
            background-color: #0056b3;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }
        .content {
            position: relative;
            z-index: 1;
            margin: 100px auto;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <canvas id="graphCanvas"></canvas>

    <div class="content">
        <h1>Visual Graph Arena Dataset</h1>
        <p>Welcome to the Visual Graph Arena dataset page! This dataset is designed for deep learning research in the field of graph theory.</p>
        <p>The dataset contains a collection of graph data and associated visual representations suitable for various graph-related tasks such as graph classification, graph generation, and graph embedding.</p>

        <h2>Dataset Details</h2>
        <ul>
            <li>Number of graphs: [Insert number of graphs]</li>
            <li>Graph types: [Insert graph types, e.g., directed, undirected, weighted]</li>
            <li>Application domains: [Insert application domains, e.g., social networks, biological networks]</li>
            <li>File format: [Insert file format, e.g., GraphML, JSON]</li>
        </ul>

        <h2>Download</h2>
        <p>To download the Visual Graph Arena dataset, click the button below:</p>
        <a href="[Insert download link]" class="download-button">Download Dataset</a>

        <h2>Citation</h2>
        <p>If you use this dataset in your research, please cite the following paper:</p>
        <pre>
[Insert citation information]
        </pre>

        <h2>Contact</h2>
        <p>If you have any questions or feedback regarding the Visual Graph Arena dataset, please contact us at [Insert contact email].</p>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const content = document.querySelector('.content');
        const contentRect = content.getBoundingClientRect();
        const boundaryTop = contentRect.top - 50;
        const boundaryBottom = contentRect.bottom + 50;
        const boundaryLeft = contentRect.left - 50;
        const boundaryRight = contentRect.right + 50;

        const nodes = [];
        const edges = [];
        const numNodes = 15;
        const nodeRadius = 5;
        const edgeLength = 100;
        const spaceMargin = 30;

        // Initialize nodes
        for (let i = 0; i < numNodes; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (Math.min(canvas.width, canvas.height) / 2 - edgeLength);
            const node = {
                x: Math.cos(angle) * radius + canvas.width / 2,
                y: Math.sin(angle) * radius + canvas.height / 2,
                vx: Math.random() - 0.5,
                vy: Math.random() - 0.5
            };
            nodes.push(node);
        }

        // Initialize edges
        for (let i = 0; i < numNodes; i++) {
            const targetIndex = Math.floor(Math.random() * numNodes);
            if (i !== targetIndex) {
                edges.push({ source: i, target: targetIndex });
            }
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx.lineWidth = 1;
            edges.forEach(edge => {
                const sourceNode = nodes[edge.source];
                const targetNode = nodes[edge.target];
                ctx.beginPath();
                ctx.moveTo(sourceNode.x, sourceNode.y);
                ctx.lineTo(targetNode.x, targetNode.y);
                ctx.stroke();
            });

            // Draw nodes
            ctx.fillStyle = 'rgba(0, 123, 255, 0.7)';
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                ctx.fill();

                // Update node position
                node.x += node.vx;
                node.y += node.vy;

                // Bounce off the text area
                if (node.x < boundaryLeft + nodeRadius + spaceMargin || node.x > boundaryRight - nodeRadius - spaceMargin){
                    node.vx *= -1;
                    node.vy *= -1;
                }
                if (node.y < boundaryTop + nodeRadius + spaceMargin || node.y > boundaryBottom - nodeRadius - spaceMargin) {
                    node.vx *= -1;
                    node.vy *= -1;
                }
            });

            requestAnimationFrame(drawGraph);
        }

        drawGraph();
    </script>
</body>
</html>
